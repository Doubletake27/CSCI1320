9/10/2019
Systems Lecture Notes
Day 5

Extension on Data Quiz until Friday Sept 13 by 11:55 pm
Extension on Data Lab until Monday Sept 16 by 8 am

Recap
  Bitwise masking using &
  Logical Operators: &&, ||, and !
  Bit Shifting: << and >>
    Corresponds to multiplication and division by powers of two
  Signed and unsigned binary encodings of integers
    Two's complement
  Integer arithmetic: Addition and multiplication
    Overflow
  Casting
    Between Signed and Unsigned integer
    Between integers of different sizes e.g. sign extension

Unsigned Power-of-2 Divide with Shift
  Quotient of Unsigned by Power of 2
    u >> k gives [u / 2^k]  <- "floor" function or RoundDown
    uses logical shift

  Quotient of Signed by power of 2
    x >> k gives [x / 2^k]
    uses arithmetic shift
    rounds wrong direction when x < 0

  Correct Power of 2 Divide
    Want [x / 2^k] (Round towards 0)
    Compute as [ (x + 2^k -1 ) / 2^k]
      adding a pre-bias 2^k - 1
      in C: (x + (1<<k)-1 >> k)
      Biases dividend toward 0

  To get RoundToZero() rounding in signed 2^k Division
    (x<0 ? x+(1<<k)-1 : x ) >> k

    this is equivalent to:

    if(x<0){
      quotient = (x + 2^K -1) >> k
    }else{
      quotient = x>>k;
    }

No Shortcuts to General Integer Division

Byte Ordering
  In what order should bytes within a multi-byte word be stored in memory?
    Consider a 32-bit integer or int (4-byes)
    0000 0001 0010 0011 0100 0101 0110 0110 0111
    0x 0    1    2    3    4    5    6    7    8

    In what order do we store these four bytes?
      Little Endian approach:
        Least significant byte gets stored first (has lowest address )
        Followed by next least significant byte
      Big Endian
        Most significant byte has lowest address
      Little endian
        Least significant byte has lowest address
      Endianness cam from Gulliver's Travels

    CPU Conventions
      Big Indian

      Little Indian
        ISA64
      Bi-Endinan
        MIPS, ARM, (Mobile Processors)

Reading Byte-Reversed Listings
  Disassembly
    Text represntation of binary machine code
    Generated by program that reads the machine code

  Instruction code | Assemby Rendition
  5b | pop %ebx
  81 c3 ab 12 00 00 | add $0x12ab
  83 bb 28 00 00 00 00 | cmp1 $0x0, 0x28 (%ebx)

  So this is little endian

Code to Print Byte Representation of Data
  Casting pointer to unsigned char * creates byte array

    typedef unsigned char *pointer;

    void show_bytes(pointer start, int len)
    {
      int i;
      for(i = 0; i < len; i++)
        printf("0x%p/t0")
        // Thers some more stuff supposed to go here
    }

  show_bytes Execution Example
    int a = 15213; // = 0x3B6D
    printfsadfasjdf
    dfasdfajsdifjasdfa


Endianness and arrays
  Integer Array Example
    int S[3];
    s[0] = 410;
    s[1] = 14;
    s[2] = 4099;

    Little Endian, S[0] will take lowest memory position
      Arrays are still consecutive even in little endian configuration

Endianness and Pointers

Representing Characters & Strings
  ASCII (American Standard Code for Information Exchange)
  Strings (Character Arrays)
    Strings should be null-terminated
      Final character \0 (0x00)
  Strings don't care about the Endianness of the system

Machine-Level Code Representation
  
